1) Зачем нужны break и continue?
break - это выход из цикла полностью
continue - это пропуск части цикла, (след. итерация)

2) Для каких целей следует использовать while, а для каких for ... in ... ?
while используется для выполнения по какому-то условию или когда неизвестно количество элементов
for используется когда известно количество элементов или количество итераций

3) Что такое pass?
Оператор-заглушка. Прапример когда нужно создать функчию, но логику функции можно описать позже

4) Чем отличаются list от tuple?
tuple неизменяемый

5) Области видимости. Классификация.
LEGB local enclosing global built-in

6) Как работает функции min и max со строками?
сравнивает в алфавитном порядке
Пример
Part-of-alphabet: list = ['a', 'b', 'c', 'x']
print(min(Part-of-alphabet))  # 'a'
print(max(Part-of-alphabet))  # 'x'

7) В python почти все это объекты. Функция тоже?
Да

8) Каким образом передаются аргументы в функцию? (2 варианта)
позиционные, именованные / a, b, c=None, *args, **kwargs

9) Что такое Pep?
PEP – Python Enhancement Proposal, предложения по развитию Python. Эти стандарты позволяют создавать унифицированную проектную документацию для новых утвержденных возможностей языка Python.
Имеет рекомендации по написанию и оформлению кода

10)Что такое анонимные функции?
Анонимные функции - это однострочные функции. lambda.


11) Зачем нужен оператор * (не про умножение)
Использование * и ** для передачи аргументов в функцию;
Использование * и **   для сбора переданных в функцию аргументов;
Использование ** для принятия только именованных аргументов;
Использование * при распаковке кортежей;
Использование * для распаковки итерируемых объектов в список/кортеж;
Использование ** для распаковки словарей в другие словари.


12)Зачем нужны ключевые слова global и nonlocal?
global для использования или изменения глобальной переменной внутри своей функции
nonlocal используется для того чтобы вложенная функция использовала переменную внешней функции. По сути образует промежуточное звено между глобальной и локальной областью

13)Что такое хеш?
функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. В результате функции мы получаем уникальное значение.

Какие базовые типы данных хэшируемые, а какие нет?
int, float, decimal, complex, bool, string, tuple, range, frozenset, bytes
все остальные не-хэшируемые

14)Что может быть ключом в словаре?
хэшируемый тип данных

15) напиши кратчайшее решение такой задачи:
- в словаре поменять местами ключи и значения
dict_swap = {1: 'q', 2: 'w', 3: 'e'}
print(dict([(v, k) for k, v in dict_swap.items()]))

- сгенерировать матрицу 5х5
print([[i]*5 for i in range(1,6)])

- получить уникальные значения из списка
Part-of-alphabet: list = ['q', 'q', 'w', 'w', 'e', 'e']
print(set(l))

16) Какие есть способы объявления строк?
string1: str = str(qwe)
string2: str = 'rty'
string3: str = "uio"
string4: str = """qazwsxedcrfvtgb"""
print(string1, string2, string3, string4)

17) Как перевернуть строку?
print('1234567890'[::-1])

18) Приведите пример модификации списка
line1: list = [1, 'a', [2, 'asd']]
line1.append((7, 8))
line1[1] = 5
print(line1)

19) Как скопировать последовательность с помощью среза?
line1: list = ['q', 'w', 'e', 1, 2, 3]
line2: list = line1[:]
print(line2)

Как скопировать без среза?
line1: list = ['q', 'w', 'e', 1, 2, 3]
line2: list = line1.copy()
print(line2)

20)Как получить перевернутую последовательность с помощью среза?
line: list = [1, 2, 3]
print(line[::-1])

21) Как получить все ключи из словаря? Все значения?
dict1.keys()
dict1.values()

Список с кортежами в которых находятся пары ключ, значение
print([(k, v) for k, v in dict1.items()])

22) Какие есть способы форматирования строк?
Конкатенация.
%-форматирование.
Template-строки.
Форматирование с помощью метода format().
f-строки.


Напишите результаты выражений и
объясните почему именно такие результаты.
x = 200 # x присваеваем значение 200
y = x   # y присваеваем ссылку x
print(x is y)  # True, проверяем ссылки
print(x == y)  # True, проверяем значения
print(id(x), id(y)) # выводим идентификатор указанного объекта


# ----------
x1 = 200 # x присваеваем значение 200
y1 = 200 # y присваеваем значение 200
print(x1 is y1)  # True, проверяем ссылки
print(x1 == y1)  # True, проверяем значения
print(id(x1), id(y1)) # выводим идентификатор указанного объекта

# int от -5 до 256 уже зарезервированы в памяти
# https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong


# ----------
x2 = 2000 # x присваеваем значение 2000
y2 = 2000 # y присваеваем значение 2000
print(x2 is y2)  # False, проверяем ссылки (в pycharm один объект)
print(x2 == y2)  # True, проверяем значения
print(id(x2), id(y2))
# в области памяти создается разные объекты 2000
